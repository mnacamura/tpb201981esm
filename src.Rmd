---
title: "Appendix S1: \\protect\\linebreak Bayesian Inference of the TAM spectrum"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  pdf_document:
    number_sections: true
    keep_tex: true
compact-title: false
documentclass: article
fontsize: 10pt
papersize: a4
indent: true
graphics: true
listings: true
tables: true
header-includes: |
    \usepackage{authblk}
    \author[1]{Mitsuhiro Nakamura}
    \author[2]{Joe Yuichiro Wakano}
    \author[1]{Kenichi Aoki}
    \author[3]{Yutaka Kobayashi}
    \affil[1]{Organization for the Strategic Coordination of Research and Intellectual Properties,
        Meiji University, Nakano 4-21-1, Nakano-ku, Tokyo 164-8525, Japan}
    \affil[2]{School of Interdisciplinary Mathematical Sciences, Meiji University, Nakano 4-21-1,
        Nakano-ku, Tokyo 164-8525, Japan}
    \affil[3]{School of Economics and Management, Kochi University of Technology, Japan}

    \usepackage{indentfirst}
    \usepackage[capitalize]{cleveref}
    \lstset{basicstyle={\small\ttfamily}}
    \renewcommand{\thesection}{S1.\arabic{section}}
    \renewcommand{\theequation}{S1.\arabic{equation}}
    \renewcommand{\thetable}{S1.\arabic{table}}
    \renewcommand{\thefigure}{S1.\arabic{figure}}
---

```{r setup, include = FALSE}
library(doParallel)
library(ggplot2)
library(kableExtra)
library(knitr)
library(magrittr)
library(readr)
library(rstan)
library(stringr)
library(tibble)

options(scipen = 100)

## knitr options
opts_chunk$set(echo = FALSE)
opts_chunk$set(cashe = TRUE)
opts_chunk$set(message = FALSE)
opts_chunk$set(warning = FALSE)
opts_chunk$set(out.width = '\\textwidth')
options(knitr.table.format = "latex")

## ggplot2 options
theme_set(theme_light(base_size = 10) +
    theme(panel.spacing = unit(1, "lines")))

## stan options
stan_args <- list( control = list(adapt_delta = .998, max_treedepth = 15)
                 , cores = 1
                 , chains = 8
                 , iter = 2000
                 , warmup = 1000
                 )

## D for each data set
ds <- read_csv( file.path("data-raw", "d.csv")
              , col_types = cols(label = col_character(), D = col_integer())
              ) %>%
    tidyr::spread(label, D) %>%
    as.list()

## Popularity spectra for empirical data sets
datasets <- list()
datasets[["empirical"]] <- c( "aurignacian_beads"
                            , "neolithic_pottery"
                            , "neolithic_ornaments"
                            , "california_basketry"
                            , "canoe_stylistic"
                            , "canoe_functional"
                            , "wnai_technology"
                            ) %>%
    purrr::map(function(name) {
                   label <- name %>%
                       gsub("_", " ", .) %>%
                       { if (grepl("wnai", .)) gsub("wnai", "WNAI", .) else str_to_sentence(.) }
                   table <- read_csv( file.path("data-raw", paste(name, ".csv", sep = ""))
                                    , col_types = cols(.default = col_integer())
                                    ) %>%
                       dplyr::filter(!is.na(frequency) & frequency > 0)
                   result <- list()
                   result[[name]] <- list(label = label, d = ds[[name]], table = table)
                   result
               }) %>%
    purrr::flatten()

## Popularity spectra for simulation data sets at time steps 200000 - 1000 * 0:9
datasets[["simulation"]] <- c( paste("simulation_island_t=", 200000 - 1000 * 0:9, sep = "")
                              , paste("simulation_lattice_t=", 200000 - 1000 * 0:9, sep = "")
                              ) %>%
    purrr::map(function(name) {
                   name_ <- sub("(simulation_\\w+)_.+", "\\1", name, perl = TRUE)
                   time_step <- sub("simulation_\\w+_(.+)", "\\1", name, perl = TRUE)
                   label <- name %>%
                       gsub("_", " ", .) %>%
                       gsub("simulation", "IBM", .)
                   table <- read_csv( file.path("data-raw", paste(name_, ".csv", sep = ""))
                                    , col_types = cols(.default = col_integer())
                                    ) %>%
                       dplyr::select(popularity, !!time_step) %>%
                       dplyr::rename(frequency := !!time_step) %>%
                       dplyr::filter(!is.na(frequency) & frequency > 0)
                   result <- list()
                   result[[name]] <- list(label = label, d = ds[[name_]], table = table)
                   result
               }) %>%
    purrr::flatten()

## Combine time steps for each simulation data set
datasets[["simulation"]][["simulation_island"]] <- list(
      label = "IBM island"
    , d = ds[["simulation_island"]]
    , table = datasets[["simulation"]][grepl("island", names(datasets[["simulation"]]))] %>%
          purrr::map_dfr(~ .$table)
    )
datasets[["simulation"]][grepl("simulation_island_t=", names(datasets[["simulation"]]))] <- NULL
datasets[["simulation"]][["simulation_lattice"]] <- list(
      label = "IBM lattice"
    , d = ds[["simulation_lattice"]]
    , table = datasets[["simulation"]][grepl("lattice", names(datasets[["simulation"]]))] %>%
          purrr::map_dfr(~ .$table)
    )
datasets[["simulation"]][grepl("simulation_lattice_t=", names(datasets[["simulation"]]))] <- NULL

## TAM spectra function
tam <- local({
    log_xi <- function(k, d, lambda, theta)
        -log(k) + k * log(lambda) +
            lgamma(d + 1) + lgamma(d + theta - k) - lgamma(d + 1 - k) - lgamma(d + theta)
    function(k, d, lambda, theta)
    exp(log_xi(k, d, lambda, theta)) / sum(exp(log_xi(1:d, d, lambda, theta)))
})
```

```{r mcmc, include = FALSE}
registerDoParallel(parallel::detectCores())

cache <- file.path("cache", "results_empirical.RData")
if (file.exists(cache)) {
    load(cache)
} else {
    model <- stan_model("model.stan")
    results_empirical <- foreach(data_set = datasets[["empirical"]]) %dopar% {
        data <- list( l = nrow(data_set[["table"]])
                    , k = data_set[["table"]][["popularity"]]
                    , m = data_set[["table"]][["frequency"]]
                    , D = data_set[["d"]]
                    )
        do.call(sampling, c(list(object = model, data = data), stan_args))
    }
    names(results_empirical) <- names(datasets[["empirical"]])
    save(results_empirical, file = cache)
}

cache <- file.path("cache", "results_simulation.RData")
if (file.exists(cache)) {
    load(cache)
} else {
    model <- stan_model("model.stan")
    results_simulation <- foreach(data_set = datasets[["simulation"]]) %dopar% {
        data <- list( l = nrow(data_set[["table"]])
                    , k = data_set[["table"]][["popularity"]]
                    , m = data_set[["table"]][["frequency"]]
                    , D = data_set[["d"]]
                    )
        do.call(sampling, c(list(object = model, data = data), stan_args))
    }
    names(results_simulation) <- names(datasets[["simulation"]])
    save(results_simulation, file = cache)
}
```

# Bayesian MCMC

Using Eq.\ (11) in the main text, we estimated parameters of the TAM spectrum for each of the
empirical data sets (introduced in the main text, Sec.\ 2) and the artificial data sets (ditto,
Sec.\ 4) by means of a Bayesian Markov chain Monte Carlo (MCMC) method.

Performing MCMC sampling, we used Stan, version `r stan_version()`, with which we employed NUTS
algorithm with tuning parameters
\lstinline{adapt_delta = `r stan_args[["control"]][["adapt_delta"]]`} and
\lstinline{max_treedepth = `r stan_args[["control"]][["max_treedepth"]]`}.
We set the other tuning parameters to their default values.
We ran `r stan_args[["chains"]] %>% formatC(format = "d", big.mark = ",")` MCMC chains of
`r stan_args[["iter"]] %>% formatC(format = "d", big.mark = ",")` steps in which first
`r stan_args[["warmup"]] %>% formatC(format = "d", big.mark = ",")` warm-up steps were dropped to
compute posterior distributions.
Listing \ref{lst:stan-code} shows the Stan code used for our estimation.
In our estimation, we fixed $D$ to the number of all sites or groups in each
empirical data set.
For priors of $\lambda$ and $\theta$, we assumed half-Cauchy distributions with scale parameter 5.

\lstinputlisting[label={lst:stan-code},caption={Stan code.}]{model.stan}

# Results of the empirical data sets

The obtained posterior distributions for the empirical data sets (Tab.\ 1 in the main text) were
sufficiently fine:
for all the parameters in all the data sets, $\hat{R}$ was almost equal to $1$, indicating that
the MCMC chains reached relaxation;
and the effective sample size, $n_{\rm eff}$, was sufficiently large for all the cases.

\Cref{fig:plot-empirical} shows the posterior predictions of TAM for the empirical data sets.
These predictions were obtained from Eq.\ (7) in the main text scaled by the number of cultural
traits and the posterior distributions of $\lambda$ and $\theta$.

# Results of the artificial data sets

From each simulation result of the IBM island and lattice models used in Sec.\ 4 in the main text,
we took 10 population snapshots at time steps $191,000, 192,000, \cdots, 200,000$ and used the all
snapshots to infer the parameters.

The obtained posterior distributions for the artificial data sets (Tab.\ 2 in the main text) were
sufficiently fine:
for all the parameters in all the data sets, $\hat{R}$ was almost equal to $1$, indicating that
the MCMC chains reached relaxation;
and the effective sample size, $n_{\rm eff}$, was sufficiently large for all the cases.

\Cref{fig:plot-simulation} shows the posterior predictions of TAM for the artificial data sets.
These predictions were again obtained from Eq.\ (7) in the main text scaled by the number of
cultural traits (per snapshot in average) and the posterior distributions of $\lambda$ and
$\theta$.

```{r plot_empirical, fig.cap = "\\label{fig:plot-empirical}Posterior predictions of TAM: empirical data (black points), posterior means (red lines), and 95\\% credible intervals (transparent red ribbons). Note that the 95\\% CIs may be too thin to be seen."}
theory <- names(datasets[["empirical"]]) %>%
    purrr::map_dfr(function(name) {
                       data_set <- datasets[["empirical"]][[name]]
                       d <- data_set[["d"]]
                       ks <- seq.int(d)
                       scale <- sum(data_set[["table"]][["frequency"]])
                       post_pred <- with(rstan::extract( results_empirical[[name]]
                                                       , c("lambda", "theta")
                                                       ), {
                           purrr::map2(lambda, theta, ~ scale * tam(ks, d, .x, .y)) %>%
                               do.call(rbind, .)
                       })
                       tibble( label = datasets[["empirical"]][[name]][["label"]]
                             , popularity = ks
                             , freq_mean = apply(post_pred, 2, mean)
                             , freq_q025 = apply(post_pred, 2, function(.) quantile(., .025))
                             , freq_q975 = apply(post_pred, 2, function(.) quantile(., .975))
                             )
                   }) %>%
    dplyr::mutate(label = factor( label
                                , levels = datasets[["empirical"]] %>% purrr::map_chr(~ .$label)
                                ))

datasets[["empirical"]] %>%
    purrr::map_dfr(function(data_set) {
                       data_set[["table"]] %>%
                           add_column(label = data_set[["label"]], .before = TRUE)
                   }) %>%
    dplyr::mutate(label = factor( label
                                , levels = datasets[["empirical"]] %>% purrr::map_chr(~ .$label)
                                )) %>%
    {
        ggplot(., aes(x = popularity)) +
            facet_wrap(~ label, scales = "free") +
            geom_point(aes(y = frequency), size = .6) +
            geom_ribbon( aes(ymin = freq_q025, ymax = freq_q975)
                       , data = theory
                       , fill = "red"
                       , alpha = .3
                       ) +
            geom_line( aes(y = freq_mean)
                     , data = theory
                     , color = "red"
                     , size = .4
                     ) +
            labs( x = "Popularity"
                , y = "Frequency"
                )
    }
```

```{r plot_simulation, fig.height = 2, fig.cap = "\\label{fig:plot-simulation}Posterior predictions of TAM: artificial data (black points), posterior means (red lines), and 95\\% credible intervals (transparent red ribbons). Note that the 95\\% CIs may be too thin to be seen."}
theory <- names(datasets[["simulation"]]) %>%
    purrr::map_dfr(function(name) {
                       data_set <- datasets[["simulation"]][[name]]
                       d <- data_set[["d"]]
                       ks <- seq.int(d)
                       scale <- sum(data_set[["table"]][["frequency"]]) / 10
                       post_pred <- with(rstan::extract( results_simulation[[name]]
                                                       , c("lambda", "theta")
                                                       ), {
                           purrr::map2(lambda, theta, ~ scale * tam(ks, d, .x, .y)) %>%
                               do.call(rbind, .)
                       })
                       tibble( label = datasets[["simulation"]][[name]][["label"]]
                             , popularity = ks
                             , freq_mean = apply(post_pred, 2, mean)
                             , freq_q025 = apply(post_pred, 2, function(.) quantile(., .025))
                             , freq_q975 = apply(post_pred, 2, function(.) quantile(., .975))
                             )
                   }) %>%
    dplyr::mutate(label = factor( label
                                , levels = datasets[["simulation"]] %>% purrr::map_chr(~ .$label)
                                ))

datasets[["simulation"]] %>%
    purrr::map_dfr(function(data_set) {
                       data_set[["table"]] %>%
                           add_column(label = data_set[["label"]], .before = TRUE)
                   }) %>%
    dplyr::mutate(label = factor( label
                                , levels = datasets[["simulation"]] %>% purrr::map_chr(~ .$label)
                                )) %>%
    {
        ggplot(., aes(x = popularity)) +
            facet_wrap(~ label, scales = "free") +
            geom_point(aes(y = frequency), size = .6) +
            geom_ribbon( aes(ymin = freq_q025, ymax = freq_q975)
                       , data = theory
                       , fill = "red"
                       , alpha = .3
                       ) +
            geom_line( aes(y = freq_mean)
                     , data = theory
                     , color = "red"
                     , size = .4
                     ) +
            labs( x = "Popularity"
                , y = "Frequency"
                )
    }
```

\clearpage{\thispagestyle{empty}}
\renewcommand{\thetable}{\arabic{table}}

```{r parameters}
list( # TAM, IBM, and statistical model
      "$D$" = "Number of groups."
      # TAM and statistical model
    , "$b$" = "Number of group bifurcations per group per unit time."
    , "$\\beta$" = "Probability that each trait is transmitted from a parental group to its offspring group in each group bifurcation."
    , "$h$" = "Number of between-group contacts per group per unit time."
    , "$\\eta$" = "Probability that each trait is transmitted from a donor group to a recipient group in each between-group contact."
    , "$\\eta^\\prime$ ($= h\\eta/b$)" = "Rate of horizontal transmission, $h\\eta$, rescaled by $b$."
    , "$\\mu$" = "Number of trait innovations per group per unit time."
      # IBM
    , "$N$" = "Number of individuals in each group."
    , "$\\tilde{\\beta}$" = "Probability that each trait is transmitted from a parent-group member to an offspring-group member in each group bifurcation."
    , "$\\tilde{\\chi}$" = "Probability that each trait is transmitted from the virtual teacher to each same-group member in each within-group contact."
    , "$\\tilde{h}$" = "Number of within-group contacts per time step."
    , "$\\tilde{\\eta}$" = "Probability that each trait is transmitted from a donor to a different-group recipient in each between-group contact."
    , "$\\tilde{\\mu}$" = "Probability that each individual innovates a novel trait per time step."
      # Statistical model
    , "$\\lambda, \\theta$" = "Parameter transformation of $\\beta$ and $\\eta^\\prime$ (Eqs.\ 8c and 8d in the main text)."
    ) %>%
    enframe(name = "Parameter", value = "Description") %>%
    knitr::kable( escape = FALSE
                , booktabs = TRUE
                , label = "parameters"
                , caption = "List of parameters."
                ) %>%
    column_spec(2, width = "13cm") %>%
    group_rows("TAM, IBM, and statistical model", 1, 1) %>%
    group_rows("TAM and statistical model", 2, 7) %>%
    group_rows("IBM", 8, 13) %>%
    group_rows("Statistical model", 14, 14)
```

\clearpage{\thispagestyle{empty}}

```{r summary_empirical}
summary_empirical <- results_empirical %>%
    purrr::map_dfr(function(fit) {
                       tbl <- summary(fit)[["summary"]] %>%
                           as_tibble() %>%
                           round(3)
                       tbl <- tbl[1:5, c(1, 3:ncol(tbl))] %>%
                           add_column( param = c( "$\\lambda$"
                                                , "$\\theta$"
                                                , "$\\beta$"
                                                , "$\\eta^\\prime$"
                                                , "$\\beta + \\eta^\\prime$"
                                                )
                                     , .before = TRUE
                                     )
                       colnames(tbl) <- c( "Parameter"
                                         , "Mean"
                                         , "SD"
                                         , "2.5\\%"
                                         , "25\\%"
                                         , "50\\%"
                                         , "75\\%"
                                         , "97.5\\%"
                                         , "$n_{\\rm eff}$"
                                         , "$\\hat{R}$"
                                         )
                       tbl
                   })
# write_csv(summary_empirical, file.path("cache", "summary_empirical.csv"))
knitr::kable( summary_empirical
            , escape = FALSE
            , booktabs = TRUE
            , label = "summary-empirical"
            , caption = "Posterior distributions of TAM as applied to empirical data."
            ) %>%
    group_rows("Aurignacian beads", 1, 5) %>%
    group_rows("Neolithic pottery", 6, 10) %>%
    group_rows("Neolithic ornaments", 11, 15) %>%
    group_rows("California basketry", 16, 20) %>%
    group_rows("Canoe stylistic", 21, 25) %>%
    group_rows("Canoe functional", 26, 30) %>%
    group_rows("WNAI technology", 31, 35) %>%
    footnote(paste( "The parameters of interest are $\\\\beta$ and $\\\\eta^\\\\prime = h\\\\eta/b$, which are defined in Table 1."
                  , "Parameters $\\\\lambda$ and $\\\\theta$ are functions of $\\\\beta$ and $\\\\eta^\\\\prime$ (Eqs.~8c and 8d)."
                  , "The estimated posterior mean and standard deviation for each parameter of each dataset are shown in the Mean and SD columns."
                  , "The columns labeled 2.5\\\\%, 25\\\\%, etc.~give the respective quantiles of the estimated posterior distribution."
                  , "Parameter $n_{\\\\rm eff}$ is the effective sample size of the autocorrelated MCMC sample, indicating the would-be sample size assuming independence."
                  , "Parameter $\\\\hat{R}$ is the potential scale reduction statistic, indicating whether the MCMC chain has reached relaxation (when is close)."
                  )
            , escape = FALSE
            , threeparttable = TRUE
            )
```

\clearpage{\thispagestyle{empty}}

```{r summary_simulation}
summary_simulation <- results_simulation %>%
    purrr::map_dfr(function(fit) {
                       tbl <- summary(fit)[["summary"]] %>%
                           as_tibble() %>%
                           round(3)
                       tbl <- tbl[1:5, c(1, 3:ncol(tbl))] %>%
                           add_column( param = c( "$\\lambda$"
                                                , "$\\theta$"
                                                , "$\\beta$"
                                                , "$\\eta^\\prime$"
                                                , "$\\beta + \\eta^\\prime$"
                                                )
                                     , .before = TRUE
                                     )
                       colnames(tbl) <- c( "Parameter"
                                         , "Mean"
                                         , "SD"
                                         , "2.5\\%"
                                         , "25\\%"
                                         , "50\\%"
                                         , "75\\%"
                                         , "97.5\\%"
                                         , "$n_{\\rm eff}$"
                                         , "$\\hat{R}$"
                                         )
                       tbl
})
# write_csv(summary_IBM, file.path("cache", "summary_IBM.csv"))
knitr::kable( summary_simulation
            , escape = FALSE
            , booktabs = TRUE
            , label = "summary-simulation"
            , caption = "Posterior distributions of TAM as applied to artificial data."
            ) %>%
    group_rows("IBM island", 1, 5) %>%
    group_rows("IBM lattice", 6, 10) %>%
    footnote("See the footnote of Table 2 for details.")
```

<!-- vim: set fdm=syntax textwidth=98 nowrap: -->
