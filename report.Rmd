---
title: Fitting the TAM spectrum to empirical data
author: Mitsuhiro Nakamura
date: "`r Sys.time()`"
output:
  pdf_document:
    # latex_engine: lualatex
    toc: false
    number_sections: true
    fig_width: 5
    fig_height: 3.09
indent: true
header-includes: |
    \usepackage{indentfirst}
    \usepackage{listings}
    \usepackage[capitalize]{cleveref}
    \lstset{
      basicstyle={\small\ttfamily},
    }
---

```{r setup, include = FALSE}
library(doParallel)
library(ggplot2)
library(glue)
library(kableExtra)
library(knitr)
library(magrittr)
library(readr)
library(rstan)
library(stringr)
library(tibble)

options(scipen = 100)
theme_set(theme_light(base_size = 10) +
    theme(panel.spacing = unit(1, "lines")))

data_sets <- c( "aurignacian_beads"
              , "neolithic_ornaments"
              , "neolithic_pottery"
              , "california_basketry"
              ) %>% purrr::map(function(name) {
    df <- read_csv( file.path("data-raw", glue(name, ".csv"))
                  , col_types = list(.default = col_integer())
                  ) %>% dplyr::filter(!is.na(frequency) & frequency > 0)
    result <- list()
    result[[name]] <- list( label = gsub("_", " ", name) %>% str_to_sentence
                          , D = NA
                          , data = df
                          )
    result
}) %>% do.call(c, .)

to_samples <- function(data)
    with(data, do.call(c, mapply(rep, popularity, frequency)))
```

```{r mcmc, include = FALSE}
registerDoParallel(parallel::detectCores())

cache <- file.path("cache.RData")
if (file.exists(cache)) {
    load(cache)
} else {
    model <- stan_model("model.stan")
    results <- foreach(data_set = data_sets) %dopar% {
        ks <- data_set$data %>% to_samples
        sampling(model, cores = 1, chains = 8, iter = 5000, warmup = 4000,
                 data = list( M = length(ks)
                            , K = ks
                            , D = max(ks)
                            ))
    }
    names(results) <- names(data_sets)
    save(results, file = cache)
}
```

# Statistical model

Let $K_1^m = \{K_1, K_2, \cdots, K_m\}$ be popularities of cultural elements $1, 2,
\cdots, m$, respectively. Supposing that they are approximately i.i.d., the
probability to observe $K_i$ is, from the TAM spectrum, given by
\begin{equation}
\label{eq:normalized-TAM}
p(K_i \mid D, \mu, e, h, \beta, \eta) = \frac{\xi_{K_i}}{\sum_{k=1}^D \xi_k}.
\end{equation}
\Cref{eq:normalized-TAM} apparently has six paremeters. However, the TAM
spectrum can be rewritten to
\begin{subequations}
\begin{equation}
\xi_k = C\frac{\lambda^k}{k} \prod_{i=1}^k \frac{D + 1 - i}{D + \theta - i}
      = C\frac{\lambda^k}{k} \frac{\Gamma(D + 1)\Gamma(D + \theta - k)}{\Gamma(D + 1 - k)\Gamma(D + \theta)}
\end{equation}
where
\begin{align}
C &= \frac{\mu^\prime}{\beta + \eta^\prime}(D-1), \\
\mu^\prime &= \frac{\mu}{e}, \\
\lambda &= 1 + \frac{\eta^\prime}{\beta},
\end{align}
and
\begin{align}
\theta &= \frac{1-\beta}{\beta}(D-1).
\end{align}
\end{subequations}
\noindent Thus, \cref{eq:normalized-TAM} actually has three parameters: $D$,
$\lambda$, and $\theta$. Note that $C$ is dropped due to normalization in
\cref{eq:normalized-TAM}, and $\beta$ and $\eta^\prime$ are recovered from
$D$, $\lambda$, and $\theta$ as
\begin{subequations}
\begin{equation}
\beta = \frac{D - 1}{D - 1 + \theta}
\end{equation}
and
\begin{equation}
\eta^\prime = \beta (\lambda - 1).
\end{equation}
\end{subequations}
\noindent The log-likelihood for the data $K_1^m$ is given by
\begin{subequations}
\label{eq:log-likelihood}
\begin{align}
L(K_1^m \mid D, \lambda, \theta) =& -\sum_{i=1}^m \log K_i + \sum_{i=1}^m K_i
\log \lambda + m \log\Gamma(D + 1) + \sum_{i=1}^m \log\Gamma(D + \theta - K_i) \nonumber \\
&- \sum_{i=1}^m \log\Gamma(D + 1 - K_i) - m \log\Gamma(D + \theta)
- m \log Z(D, \lambda, \theta),
\end{align}
where
\begin{equation}
Z(D, \lambda, \theta) = \sum_{k=1}^D \frac{\lambda^k}{k}\frac{\Gamma(D + 1)\Gamma(D + \theta - k)}{\Gamma(D + 1 - k)\Gamma(D + \theta)}.
\end{equation}
\end{subequations}

# Bayesian MCMC

Using \cref{eq:log-likelihood}, we estimated the parameters for each of data
sets (Aurignacian beads, Neolithic ornaments, Neolithic pottery, and
California basketry) by means of Bayesian MCMC (Stan, version 2.18.2).
Performing MCMC, we employed NUTS algorithm with default parameters, set in
Stan 2.18.2, unless otherwise stated. We run eight chains of $5,000$ MCMC steps
in which first $4,000$ warm-up steps were dropped to calculate posterior
distributions.

Listing \ref{lst:stan-code} shows the Stan code used for our estimation.
In our estimation, we fixed $D (= \max_i(K_i))$ because the data sets are
complete survey. For priors of $\lambda$ and $\theta$, we assumed half-Cauchy
distributions with scale parameter $5$.

\lstinputlisting[label={lst:stan-code},caption={Stan code.}]{model.stan}

# Results

\Cref{tab:mcmc-results} shows the summary of obtained posterior distributions
for the data sets. For all the parameters in all the data sets, $\hat{R}$ is
almost equal to $1$, indicating that MCMC chains reached relaxation. More
over, the effective sample size, $n_{\rm eff}$, is sufficiently large for all
the cases.

```{r results, echo = FALSE}
options(knitr.table.format = "latex")

summary_df <- results %>% purrr::map_dfr(function(fit) {
    df <- summary(fit)$summary %>% as_tibble %>% round(3)
    df <- df[1:4, c(1, 3:ncol(df))] %>%
        add_column( param = c( "$\\lambda$"
                             , "$\\theta$"
                             , "$\\beta$"
                             , "$\\eta^\\prime$"
                             )
                  , .before = TRUE
                  )
    colnames(df) <- c( "Parameter"
                     , "Mean"
                     , "SD"
                     , "2.5\\%"
                     , "25\\%"
                     , "50\\%"
                     , "75\\%"
                     , "97.5\\%"
                     , "$n_{\\rm eff}$"
                     , "$\\hat{R}$"
                     )
    df
})

knitr::kable(summary_df, escape = FALSE, booktabs = TRUE
            , label = "mcmc-results"
            , caption = "Summary statistics of posterior distributions."
            ) %>%
    group_rows("Aurignacian beads", 1, 4) %>%
    group_rows("Neolithic ornaments", 5, 8) %>%
    group_rows("Neolithic pottery", 9, 12) %>%
    group_rows("California basketry", 13, 16)
```

\Cref{fig:plot} shows the fitted TAM spectrum for each of the data sets. The
theorecal lines are obtained by substituting $\lambda$ and $\theta$ in
\cref{eq:normalized-TAM} with their posterior means shown in
\cref{tab:mcmc-results}, scaled by the number of cultural elements.

```{r plot, echo = FALSE, fig.cap = "\\label{fig:plot}Fitted TAM spectra (red lines) to empirical data (black points)."}
log_xi <- function(k, D, lambda, theta)
    -log(k) + k * log(lambda) +
        lgamma(D + 1) + lgamma(D + theta - k) - lgamma(D + 1 - k) - lgamma(D + theta)
theory <- function(ks, D, lambda, theta)
    exp(log_xi(ks, D, lambda, theta)) / sum(exp(log_xi(1:max(ks), D, lambda, theta)))

empirical_df <- data_sets %>% purrr::map_dfr(function(data_set) {
    data_set$data %>% add_column(label = data_set$label, .before = TRUE)
})
empirical_df$label <- factor( empirical_df$label
                            , levels = data_sets %>% purrr::map_chr(~ .$label)
                            )
theoretical_df <- names(data_sets) %>% purrr::map_dfr(function(name) {
    df <- data_sets[[name]]$data
    fit <- results[[name]]
    ks <- 1:max(df$popularity)
    D <- max(ks)
    lambda <- rstan::extract(fit, "lambda")[[1]] %>% mean
    theta <- rstan::extract(fit, "theta")[[1]] %>% mean
    scale <- sum(df$frequency)
    tibble( label = data_sets[[name]]$label
          , popularity = ks
          , frequency = scale * theory(ks, D, lambda, theta)
          )
})
theoretical_df$label <- factor( theoretical_df$label
                              , levels = data_sets %>% purrr::map_chr(~ .$label)
                              )

ggplot(empirical_df, aes(popularity, frequency)) +
    facet_wrap(~ label) +
    geom_point() +
    geom_line(data = theoretical_df, color = "red") +
    scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    labs( x = "Popularity"
        , y = "Frequency"
        )
```

<!-- vim: set fdm=syntax: -->
